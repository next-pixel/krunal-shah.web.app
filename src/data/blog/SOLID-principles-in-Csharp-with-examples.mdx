---
featured: true
title: 'SOLID principles in C# with examples'
summary: 'SOLID is an acronym for five design principles that are commonly used in object-oriented programming. They were first introduced by Robert C. Martin, also known as Uncle Bob.'
published: '05/25/2023'
last_modified: '05/25/2023'
author_name: 'Krunal Shah'
author_image: '/static/avatar.jpg'
tags: ['SOLID principles']
keywords: ['SOLID principles','c#','SOLID principles in c#','object-oriented programming', 'design principles','Uncle Bob','SRP','OCP','LSP','ISP','DIP']
---

## What are SOLID principles?

SOLID is an acronym for five design principles that are commonly used in object-oriented programming. They were first introduced by Robert C. Martin, also known as Uncle Bob. The principles are:

### There are many ways to apply SOLID principles in Csharp. Here are a few examples:

### Single Responsibility Principle: 
One way to apply the SRP is to create small, focused classes. Each class should have a single responsibility, and it should only contain the code that is necessary to fulfill that responsibility. This makes classes easier to understand, test, and maintain.

A class should have only one responsibility. This means that it should only have one reason to change.

The Single Responsibility Principle (SRP) states that a class should have only one responsibility. This means that it should only have one reason to change.

For example, lets say we have a class called Car. This class might have the following responsibilities:

* Calculate the cars fuel efficiency
* Calculate the cars emissions
* Start the car
* Stop the car

As you can see, this class has multiple responsibilities. This makes it difficult to understand, test, and maintain.

To follow the SRP, we would need to refactor the Car class into multiple classes. For example, we could create a CarEngine class to handle the responsibilities of calculating fuel efficiency and emissions. We could also create a CarController class to handle the responsibilities of starting and stopping the car.

By following the SRP, we have created smaller, more focused classes. This makes our code easier to understand, test, and maintain.

Here is an example of how to apply the SRP in C#:

```CSharp
public class CarEngine
{
    public double CalculateFuelEfficiency(double distance, double fuelUsed)
    {
        return distance / fuelUsed;
    }

    public double CalculateEmissions(double distance, double fuelUsed)
    {
        return fuelUsed * 0.25;
    }
}

public class CarController
{
    public void StartCar()
    {
        // Start the car
    }

    public void StopCar()
    {
        // Stop the car
    }
}
```

Use code with caution. Learn more
As you can see, these classes are much smaller and more focused than the original Car class. This makes them easier to understand, test, and maintain.

The SRP is one of the most important design principles in object-oriented programming. By following the SRP, you can create code that is more flexible, readable, testable, maintainable, and reusable.

### Open/Closed Principle: 
One way to apply the OCP is to use interfaces. An interface is a contract that defines a set of methods. A class can implement an interface to provide an implementation for those methods. This makes it easy to add new functionality to a class without changing existing code.

Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. This means that new functionality should be added without changing existing code.

The Open/Closed Principle (OCP) states that software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. This means that new functionality should be added without changing existing code.

One way to implement the OCP is to use interfaces. An interface is a contract that defines a set of methods. A class can implement an interface to provide an implementation for those methods. This makes it easy to add new functionality to a class without changing existing code.

For example, lets say we have a class called Car. This class might have the following methods:

* Start()
* Stop()
* Accelerate()
* Brake()

We can now create an interface called IVehicle that defines these methods. The Car class can then implement the IVehicle interface.

```CSharp
public interface IVehicle
{
    void Start();
    void Stop();
    void Accelerate();
    void Brake();
}

public class Car : IVehicle
{
    public void Start()
    {
        // Start the car
    }

    public void Stop()
    {
        // Stop the car
    }

    public void Accelerate()
    {
        // Accelerate the car
    }

    public void Brake()
    {
        // Brake the car
    }
}
```

Use code with caution. Learn more
Now, we can create a new class called Truck that also implements the IVehicle interface.

```CSharp
public class Truck : IVehicle
{
    public void Start()
    {
        // Start the truck
    }

    public void Stop()
    {
        // Stop the truck
    }

    public void Accelerate()
    {
        // Accelerate the truck
    }

    public void Brake()
    {
        // Brake the truck
    }
}
```

Use code with caution. Learn more
As you can see, we have added new functionality to our code (the Truck class) without changing any existing code (the Car class). This is because we used interfaces to define the new functionality.

The OCP is one of the most important design principles in object-oriented programming. By following the OCP, you can create code that is more flexible, readable, testable, maintainable, and reusable.

### Liskov Substitution Principle: 
One way to apply the LSP is to make sure that subclasses are not more specialized than their base classes. This means that a subclass should be able to be used in place of its base class without any problems.

Subclasses should be substitutable for their base classes. This means that a client that uses a base class should be able to use a subclass without any problems.

The Liskov Substitution Principle (LSP) states that objects of a superclass should be replaceable with objects of its subclasses without breaking the application. This means that a client that uses a base class should be able to use a subclass without any problems.

For example, lets say we have a class called Animal. This class might have the following methods:

* MakeSound()
* Eat()
* Sleep()

We can now create a subclass called Dog that inherits from the Animal class. The Dog class can then override the MakeSound() method to make a barking sound.

```CSharp
public class Animal
{
    public void MakeSound()
    {
        // Make an animal sound
    }

    public void Eat()
    {
        // Eat some food
    }

    public void Sleep()
    {
        // Go to sleep
    }
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        // Bark
    }
}
```

Now, we can create a client that uses the Animal class.

```CSharp
public class Client
{
    public void MakeAnimalSound(Animal animal)
    {
        animal.MakeSound();
    }
}
```

We can then use the Client class to make a dog sound.

```CSharp
var client = new Client();
var dog = new Dog();

client.MakeAnimalSound(dog);
```

As you can see, the Dog object is able to be used in place of the Animal object without any problems. This is because the Dog class follows the LSP.

The LSP is one of the most important design principles in object-oriented programming. By following the LSP, you can create code that is more robust and reliable.

### Interface Segregation Principle: 
One way to apply the ISP is to create interfaces that are only as large as they need to be. An interface should only expose methods that are actually used by clients. This makes interfaces easier to understand and use.

Clients should not be forced to depend on methods they do not use. This means that an interface should only expose methods that are actually used by clients.

    The Interface Segregation Principle (ISP) states that clients should not be forced to depend on methods they do not use. This means that an interface should only expose methods that are actually used by clients.

        For example, lets say we have an interface called IVehicle. This interface might define the following methods:
        
        * Start()
        * Stop()
        * Accelerate()
        * Brake()
        
        
        As you can see, this interface exposes methods that are not used by all clients. For example, a client that only needs to start and stop a vehicle does not need to know how to accelerate or brake.
        
        To follow the ISP, we would need to create multiple interfaces. For example, we could create an interface called IStartStopVehicle that defines the Start() and Stop() methods. We could also create an interface called IAccelerateBrakeVehicle that defines the Accelerate() and Brake() methods.
        
        Now, clients can only depend on the interfaces that they need. For example, a client that only needs to start and stop a vehicle can depend on the IStartStopVehicle interface.
        
        ```CSharp
        public interface IStartStopVehicle
        {
            void Start();
            void Stop();
        }
        
        public interface IAccelerateBrakeVehicle
        {
            void Accelerate();
            void Brake();
        }
        
        public class Car : IStartStopVehicle, IAccelerateBrakeVehicle
        {
            public void Start()
            {
                // Start the car
            }
        
            public void Stop()
            {
                // Stop the car
            }
        
            public void Accelerate()
            {
                // Accelerate the car
            }
        
            public void Brake()
            {
                // Brake the car
            }
        }
        ```
        
        As you can see, this code is more modular and easier to understand. This is because each interface only exposes methods that are used by clients.
        
        The ISP is one of the most important design principles in object-oriented programming. By following the ISP, you can create code that is more flexible, readable, testable, maintainable, and reusable.
    
### Dependency Inversion Principle: 
One way to apply the DIP is to use dependency injection. Dependency injection is a technique where a class receives its dependencies from an outside source. This makes it easy to change the dependencies of a class without changing the class itself.
Benefits of using SOLID principles

High-level modules should not depend on low-level modules. Both should depend on abstractions. This means that a module should not depend on a specific implementation of a dependency. Instead, it should depend on an abstraction that represents the dependency.
How to apply SOLID principles in Csharp

High-level modules should not depend on low-level modules. Both should depend on abstractions.

In other words, high-level modules should not be tightly coupled to low-level modules. This means that high-level modules should not know about the implementation details of low-level modules. Instead, high-level modules should depend on abstractions, which are interfaces or abstract classes that define the behavior of low-level modules.

This principle can be applied to Csharp code in a number of ways. For example, lets say we have a high-level EmployeeBusinessLogic class that needs to access data from a database. We could implement this class as follows:

```CSharp
public class EmployeeBusinessLogic
{
    private readonly EmployeeDataAccess _dataAccess;

    public EmployeeBusinessLogic(EmployeeDataAccess dataAccess)
    {
        _dataAccess = dataAccess;
    }

    public void GetEmployees()
    {
        return _dataAccess.GetEmployees();
    }
}
```

As you can see, this class is tightly coupled to the EmployeeDataAccess class. This means that if we want to change the database that we are using, we will need to change this class as well.

To follow the DIP, we can refactor this class as follows:

```CSharp
public class EmployeeBusinessLogic
{
    private readonly IEmployeeDataAccess _dataAccess;

    public EmployeeBusinessLogic(IEmployeeDataAccess dataAccess)
    {
        _dataAccess = dataAccess;
    }

    public void GetEmployees()
    {
        return _dataAccess.GetEmployees();
    }
}

public interface IEmployeeDataAccess
{
    IEnumerable<Employee> GetEmployees();
}

public class EmployeeDataAccess : IEmployeeDataAccess
{
    public IEnumerable<Employee> GetEmployees()
    {
        // ...
    }
}
```

In this refactoring, we have replaced the concrete EmployeeDataAccess class with an abstract IEmployeeDataAccess interface. This allows us to decouple the EmployeeBusinessLogic class from the implementation details of the database. Now, we can easily change the database that we are using without having to change the EmployeeBusinessLogic class.

The DIP is an important design principle that can help you to create more maintainable and flexible software. By following this principle, you can decouple your high-level modules from your low-level modules, which will make your code easier to change and extend.

### There are many benefits to using SOLID principles in Csharp. Here are a few of the most important benefits:

#### Increased flexibility: 
SOLID principles make it easier to change code without breaking anything. This is because SOLID code is well-designed and modular.

#### Improved readability: 
SOLID code is easier to read and understand because it is well-organized and well-documented.

#### Increased testability: 
SOLID code is easier to test because it is well-designed and modular.

#### Reduced coupling: 
SOLID code is less coupled to other code, which makes it easier to maintain and evolve.

#### Increased maintainability: 
SOLID code is easier to maintain because it is well-designed and modular.

## Conclusion
SOLID principles are a set of design principles that can be used to improve the quality of Csharp code. 
By following these principles, developers can create code that is more flexible, readable, testable, maintainable, and reusable.